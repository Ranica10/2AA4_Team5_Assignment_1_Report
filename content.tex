\section{Executive summary}

This assignment required us to create a simulator for the board game 'Settlers of Catan.' The simulator creates a game map, plays games with four computer-controlled players, and follows the rules of the game until a player wins. We were required to do this assignment in several steps: first, creating a UML diagram to lay out how we wanted our game to be structured, and then implementing that diagram in actual Java code. We also attempted to use AI to create code for us from our diagram to see how well it would actually work. The code created by the AI looked good at first, but it had logical errors that we had to correct. The final version of the simulator does what it is supposed to—it keeps track of resources, builds roads and settlements, enforces the distance rules between pieces, and prints out what each player does each turn. The entire experience has taught us that while diagrams are useful for planning, you still have to go back and fix your design when you start actually coding. Going through the assignment step by step helped to understand why software engineering is more than just coding—it’s about thinking through problems before building them.

\section{Requirements traceability}

    \begin{longtable}{|p{1.2cm}|p{2.5cm}|p{2.5cm}|p{8cm}|}
    \caption{Requirements Traceability Matrix} \\
    \hline
    \textbf{Req ID} & \textbf{Status} & \textbf{Status} & \textbf{Design considerations} \\
    \hline
    \endfirsthead

    
    R1.1 & Implemented & \code{Board.java} & The software shall first set up a valid map. Use the specified identification mechanism for tiles and nodes. \\
    \hline
    R1.2 & Implemented & \code{Player.java}, \code{Game.java} & The simulator shall be able to simulate 4 randomly acting agents (playing on the map generated in R1.1). \\
    \hline
    R1.3 & Implemented & \code{Game.java} & The simulation must follow the rules outlined in the attached rulebook. (Minus some features and feature groups listed below, after the requirements.) \\
    \hline
    R1.4 & Implemented & \code{Game.java} & The simulator shall be able to simulate the game for a user-defined number of rounds (maximum 8192 rounds, i.e., 8192x4=32768 turns) or until 10 VPs are collected by any of the agents. The configuration is defined in a configuration file. \\
    \hline
    R1.5 & Implemented & \code{Game.java} & The simulator shall halt execution upon reaching one of the termination conditions identified in R1.4. \\
    \hline
    R1.6 & Implemented & \code{Board.java} & The key invariants of the game must be respected, including: new roads must be connected to existing ones or roads or settlements; newly built cities must replace existing settlements; the distance between different players' settlements/cities must be at least two; etc. \\
    \hline
    R1.7 & Implemented & \code{Game.java} & The simulator shall print the actions taken by the agents on the console in the specified encoding. [Spec] The simulator shall print the current victory points at the end of each round. \\
    \hline
    R1.8 & Implemented & \code{Board.java}, \code{Player.java} & Agents with more than 7 cards in their hand must try to spend those cards by building something. \\
    \hline
    R1.9 & Implemented & \code{Main.java} & The key functionality of the simulator must be demonstrated in a sufficiently detailed Demonstrator class with one static void main method in it that will run one or more demonstrative simulations. The demonstrator is to be properly explained by comments in the code (and in the report). \\
    \hline
\end{longtable}



\section{Design and domain modeling}

\textbf{Why was this modelling stage useful and what benefits does your domain model have compared to the specification in the attached PDF?}

Domain modelling was useful because it helped us understand the problem at a high level before focusing on implementation. By using UML in Papyrus, we identified the key entities such as Board, Tile, Node, Road, Player, Building, etc., and their relationships, making the structure of the system clear and understandable. 

Compared to the specification in the PDF, the domain model provides a clearer and more visual representation of the program. While it explains roles in text, the UML shows more responsibilities and relationships of each class, improving our understanding and supporting a cleaner object-oriented design. 

\textbf{How does the natural language description in the rulebook motivate conceptual modelling? Was this step necessary? Was this step beneficial? If you believe it was beneficial, name three concrete benefits. (Hint: you can imagine an even more complex software system, e.g., a real banking system with many user roles, transaction rules, etc.)}

The natural language description in the rulebook helps motivate conceptual modelling because it explains how the game works in teams of actions, objects and rules, such as players, resources,and turns. These ideas can then be translated into classes and relationships. This step was necessary because it ensures we understand the requirements before designing the game. Without it, important elements or roles could be missed. It helps identify key entities early, reduces design errors and makes the system easier to implement and modify. In more complex systems, like banking software, this step is even more important because misunderstanding requirements can lead to serious problems. 

\textbf{There are at least two aspects of the problem you did not model. What are these? How (in what formalism) would you model those elements?}

1. The game logic, like turn order, dice rolling, trading rules, or win conditions were not implemented in this problem. These help with how the game runs, not the structure. They can be modelled using different methods, taking care of a specific part of the logic, for example, startTurn, rollDice, etc., would be the different parts of the player’s turn. 
\newline
2. User interaction was not modelled either. This would include players providing input and how the game is displayed. These are separate from game logic and would be handled using UI, and divided into three bits: the game data and rules, what the player sees, and user actions. 

\textbf{Elaborate on how OO mechanisms helped you design the system. }

Object-oriented mechanisms helped structure the system by organizing the game into well- defined classes with clear responsibilities. Encapsulation allowed each class to manage its own data and behaviours, reducing complexity and making the design easier to understand.

For example, instead of using primitive values to represent the game concepts, such as the resource types (i.e., wood, lumber, etc.), our system uses a Resources enumeration instead. This directly reflects the mechanism of avoiding using magic numbers by instead embedding meaning into the types. Additionally, encapsulating resources within an enum also prevents invalid inputs at compile time and improves the safety of the system by ensuring that only valid resource types can exist within the application.

Abstraction also played an important role by allowing common concepts to be modelled at a higher level, making design independent of implementation details. 

This may be reflected through the Building abstract class, which holds shared behaviour across different building types, while subclasses such as Settlement and City provide specific implementations. This abstraction allows the Player to store a map of buildings using the Building type rather than their specific subclasses. By relying on polymorphism, the player can treat all buildings uniformly while still allowing the Settlement and City subclasses to exhibit different behaviour, such as contributing to different point values.

Overall, these OO mechanisms supported a maintainable design and provided a clear implementation of the problem. 

\textbf{Elaborate on the SOLID principles used in your design}
There are several SOLID principles that are used in the design:
	
\textbf{1. Single Responsibility Principle:} Each class has a clear responsibility, focused on just one task. For example, the Board class manages the game layout, the Player class manages player-related attributes and methods, etc. This helps with readability and maintains the code better
\newline
\textbf{2. Open/Closed Principle:} The system is open for extension but closed for modification. For example, new building types can be added by extending the Building abstract class without changing the existing logic. This also reduces the risk of bugs.
\newline
\textbf{3. Liskov Substitution Principle:} Settlement or City subclasses don’t require the Building superclass, and it can replace it without breaking the code. This makes sure that polymorphism works in the code.
\newline
\textbf{4. Interface Segregation Principle:} The Interface Segregation Principle states that classes should not be forced to depend on methods they do not use. Instead of creating one large interface that handles all game actions, the design should separate behaviour into smaller, specific interfaces. In this application, different game entities perform very different actions. For example, a Player can build on their turn, while the Board only needs behaviour related to resource production.
\newline
\textbf{5. Dependency Inversion Principle:} The Dependency Inversion Principle states that entities should depend on abstractions and not concretes. In this design, the game logic does not directly depend on concrete classes like Settlement or City. Instead, it depends on the abstract type Building. For example, the Player is able to store buildings using the abstract Building type rather than its specific subclasses. As a result of the player depending on the abstraction rather than concrete implementations, new building types can be added without modifying the Player class.

\section{Translating engineering models to program code}

\textbf{What are the translational semantics of this step? In other words: what in your design model maps to what in your program code? What are the benefits of this step? When would you use this approach (modelling and translation) and when would you skip the modelling part and start writing program code immediately?}

In our project, each class in the UML diagram becomes a Java class. Abstract classes in our UML diagram were written with the abstract keyword, the resources enumeration became a Java enum, and relationships between classes were represented by object references and lists in the code. For example, the Board class has a list of Tile, Node, and Road Objects, just as shown in the diagram. Inheritance in the UML using arrows used the extends keyword. Eclipse with Papyrus was used to create the UML diagram. Then we generated the class skeletons with Papyrus. This step helped to reduce confusion, since the structure was already designed in UML. It helped prevent structural mistakes when writing the code, as the code was generated from UML using Papyrus, and the class relationships were correct. This approach is useful for projects where structure is important. It is very helpful when working in a team, as everyone can agree on the design before coding. However, when working on small programs, it may be easier to start coding directly without making a UML diagram because the relationships are simpler. 

\section{Using Generative AI}

\textbf{What did your gen AI tool did well? What are its strengths?}

The gen AI performed well in translating the UML to structured Java code. It correctly identified the classes, attributes and methods, inheritance and associations, thus creating a logical class skeleton that closely matches the class diagram. Another strength was its ability to organize the code so it is easy to understand and is readable. It also followed OOP principles such as encapsulation and abstraction.

\textbf{What mistakes did your gen AI tool make? What are its weaknesses?}

Even though the gen AI tool has its strengths, it also has some weaknesses.
It is focused more on the structure, rather than the behaviour. For instance, the class definitions were consistent with the UML diagram, but the implementation of the method itself lacked proper logic, since it didn’t know what exactly we wanted it to implement for the game. It made certain assumptions about the game logic. These assumptions may or may not be consistent with the actual game implementation. Therefore, we need to provide some more details to the tool for it to properly implement the logic.

\textbf{How would you use gen AI in a large-scale software project? How would you balance its strengths and weaknesses?}

Gen AI would be most useful as a productivity tool and a supporting tool in a large-scale software project. It would be used as a tool for creating initial code, scaffolding, documentation, and refactoring suggestions. In balancing the strengths and weaknesses of Gen AI, it is imperative that all code created by the AI be reviewed, tested and also validated by humans, while critical parts of the code are designed by human developers only.

\textbf{You run a company and you need to develop a software tool for your clients. Your user base is roughly 1 million people. Each user is willing to pay \$1000 for the software tool you have in mind. With every passing day, you lose 10 potential clients. (This is a rough estimate that lumps market dynamics and competition into one variable. Let’s assume that marketing, sales, delivery, etc are instantaneous and once the product is ready, users will download it and pay you the \$1000.) Poor quality of the final product will result in higher customer churn rate, i.e., customers will abandon the product and ask back for their money. (Let’s assume that you would pay back to money without engaging in litigation.) Your goal, as a company, is to maximize your revenue. You consult your software team to see your options. They suggest four potential strategies as shown in the table below. Which strategy would you use and why?
}

Cowboy coding - no design phase, 20 days manual programming, churn rate 0.25

Total time: 20 days

Net customers: (1000000 - 10 x 20) x (1 - 0.25) = 998000 x 0.75 = 748500

Revenue: \$748.5 million

Vibe coding - no design phase, 10 days of AI programming, churn rate 0.33

Total time: 10 days

Net customers: (1000000 - 10 x 10) x (1 - 0.33) = 999000 x 0.67 = 669330

Revenue: \$669.33 million

Conventional SE - 20 days design, 20 days manual programming, churn rate 0.05

Total time: 40 days

Net customers (1000000 - 10 x 40) x (1 - 0.05) = 996000 x 0.95 = 946200

Revenue: \$946.2 million

Model-driven SE - 25 days formal design, 5 days generative programming, churn rate 0.025

Total time: 30 days

Net customers: (1000000 - 10 x 30) x (1 - 0.025) = 997000 x 0.975 = 972075

Revenue: \$972.075 million

The best software development strategy in this case is Model-driven Software Engineering, given its highest projected revenues of close to \$972 million. This software engineering strategy has a 25-day formal software design phase, which is then combined with an equally effective but faster generative programming phase, requiring just 5 days of coding. Therefore, the entire software development phase occurs in just 30 days. It has a low churn rate of just 2.5\%. In spite of the long design phase requiring a substantial level of investment, the overall software product reliability is improved due to its formal nature, resulting in very low refunds. In comparison, Conventional SE, which has also been used in previous tasks, does produce a good revenue of almost \$946 million but has a much longer development phase of 40 days. The other two strategies, Cowboy coding and Vibe coding, which are faster, result in much lower revenues of around \$749 million and \$669 million, respectively, given that the time saved is completely overshadowed by low product reliability and higher churn rates.

\section{Implementation}

\textbf{Now that you are in the implementation phase, reflect on this: did you get the domain models right at the first attempt, or did you iterate between modelling and implementation? If you did iterate, why and how? What does this say about your design and a human’s modelling capability? (Hint: is there a difference in the level of abstraction when modelling vs when implementing software code?)}

During implementation, we did not get the domain model completely right on the first attempt. We had to iterate between modelling and implementation several times. For example, in our UML, the takeTurn() method was placed inside the Player class. However during implementation, we realized that turn logic required coordination between multiple components such as Board, Tile, Node and Dice. Because of this, we refactored the design and moved the takeTurn() to the Board class, where it made sense for managing the overall game. To improve readability, maintainability , and follow good design practices, we separated the takeTurn methods into a few helper methods:  produceResource(), buildRoad(), buildSettlement(), buildCity(), isRoadConnected(), and addRoadToBoard(). This separation allowed each method to focus on a single task, making the code easier to understand and modify. 

We also added more functionality in the Board class to connect Tile and Node objects, which was not fully specified in the original UML, it is a helper method as well to connect the tile and nodes on the board. We updated the method in the Player class as well, added some helper methods, such as addResource() and addBuilding(), which were not fully defined in the UML, but were necessary to make the program work properly. 

Modelling and implementation operate at different levels of abstraction. In UML, we focused on high level relationships, but during coding we had to consider details like object interactions and structured code. This showed us that initial design often needs refinement and iteration is a natural part of developing software. 

\textbf{What were some of the challenges in these iterations (technical or conceptual)? What tools or integrated tool chains would help you in those steps? (You can specify a few abstract ideas, you don’t have to name specific tools or techniques.)}

During implementation, we faced both technical and conceptual challenges. Conceptually, it was hard to predict all the interactions between players, the board, tile, and resources. Technically, we had to figure out how to track resources, buildings and points correctly, and make sure actions like building or gaining resources worked without errors. Some approaches that we used: 
\begin{itemize}
    \item Simulation- to test how the game behaves. 
    \item Iterative modeling- to update UML diagrams as things modify.
    \item Unit testing- to check individual methods work correctly
\end{itemize}

These approaches help make the transition from abstract design to working code easier and more reliable.

\textbf{Elaborate on the OO mechanisms and SOLID principles in your implementation. Are these any different from the ones used in the design? If they are: why?}

Object oriented mechanisms helped us organise the systems clearly. Encapsulation was used by making the attributes private to control who had access to them. Abstraction was used through the Building abstract class, which allowed different building types to behave similarly. Polymorphism let the Player class treat all buildings as Building objects (Cities, Settlements, and Roads), even though they might be different classes. This made it easy to implement and the code flexible. 
SOLID principles were also used in our implementation. The Single Responsibility principle is followed as every class has one job. For example, the Board class manages the layout, Player class manages player data, and the Game class controls the game flow. The Open Closed principle is followed as we can add new building types by extending Building class without changing any existing code. The Liskov Substitution Principle is followed as Settlement, Cities, and Road classes can be used anywhere a Building object is required without creating errors, and can standalone. The Interface Segregation Principle is followed as abstract classes only include methods that are required. Subclasses do not have to implement methods that are not required by them. The Dependency Inversion Principle is followed as the Player class depends on the abstract Building type than the subclasses. In the design phase, we thought of what implementations could look like, in the implementation phase, we had to apply them carefully to make sure that they worked. 

\section{Reflection on the engineering process}

\textbf{What communication channels did you use?}
We relied on Microsoft Teams as our main communication platform, enabling online meetings, discussions, and file sharing. Additionally, we used the Messages app for quick updates among team members.

\textbf{How did you handle the time pressure?}
To handle the time pressure, we distributed the workload among all team members so that the tasks were evenly divided. This ensured that the burden of completing all the tasks was not on one person and that multiple aspects of the project could be worked on simultaneously.

\textbf{What was the hardest organizational part of this assignment? What did you learn from it and what will you do to mitigate those issues next time?}

The hardest part of this assignment was making sure that everyone understood the UML diagram in the same way before starting to work on implementing the code. Even though the diagram is clear, team members can interpret UML diagrams and their relationships differently. This made us make adjustments to our UML and our code. We learned that spending more time reviewing the UML together before generating the code would reduce the confusion later. In the future, we will do a short review of the design process before working on the code.

\section{Roles and responsibilities}

The team members contributed equally to the deliverable. \id{This is the ideal situation, but in case the workload has not been equal, please, report accordingly.}

\begin{itemize}
    \item \TODO{\textbf{John Doe} contributed to the conceptual design and the implementation of RQ1.1.}
    \item \TODO{...}
\end{itemize}
